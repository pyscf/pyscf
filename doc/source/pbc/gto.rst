.. _pbc_gto:

pbc.gto --- Crystal cell structure
**********************************
This module provides functions to setup the basic information of PBC
calculation.  It is an analogy to the molecule basic module :mod:`pyscf.gto`.
The basic :class:`Cell` class for crystal structure are defined in this module.
Basis set, pseudo potentials are parsed in this module.

:class:`Cell` class
===================
We defined in this module the :class:`.Cell` class as an extension of molecular
:class:`pyscf.gto.mole.Mole` class.  The :class:`Cell` object offers the same
functionality as the :class:`Mole` object.  One can use :class:`Cell` object to
access the structure, the basis functions, pseudo potentials, certain analytical
periodic integrals.

Similar to the input in molecule calculation, one need first create a
:class:`Cell` object, after assigning the crystal parameters, one need call
:func:`build` to initialize the :class:`Cell` object.  A shortcut function
:func:`M` is available as module level to simplify the input.

.. literalinclude:: ../../../examples/pbc/00-input_cell.py

Addition to the basic parameters :attr:`atom`, :attr:`basis`, you need at least
set the lattice parameter :attr:`h`, the dense of FFT-mesh :attr:`gs` to
describe the cell.

.. note::

    The lattice vector .h is a 3x3 array. Each column of .h array is a real space
    primitive vector.

In certain systems, it is convenient to choose the FFT-mesh based on the kinetic
energy cutoff.  The :class:`Cell` class offers an alternative attribute
:attr:`ke_cutoff` to set the FFT-mesh.  If :attr:`ke_cutoff` was set and
:attr:`gs` is blank,  :class:`Cell` initialization function will convert the
:attr:`ke_cutoff` to the FFT-mesh and overwrite the :attr:`gs` attribute in
terms of the relation :math:`\mathbf{g} = \frac{\sqrt{2k_{cut}}}{2\pi}\mathbf{h}`.
Aside from these parameters, the pseudo potential :attr:`pseudo` is another
attribute commonly required by many calculations (see also :ref:`pseudo`).

The input parameters ``.h`` and ``.pseudo`` are immutable in the :class:`Cell`
object.  The input format might be different to the internal format required
by the program.  Similar to the convention in :class:`Mole`, the internal Python
data layer is created to hold the formatted ``.h`` and ``.pseudo`` parameters.

_h
  Lattice vectors in atomic unit.

_pseudo
  The internal format to hold PBC pseudo potential parameters.  It is
  represented with nested Python lists only.

There are some attributes of :class:`Cell` relevant to the calculation accuracy.
They are :attr:`nimgs` the number of repeated images in the real space lattice
summation, :attr:`ew_eta` and :attr:`ew_cut` the model charge and the energy
cutoff to control the accuracy of Ewald summation.  Generally, we don't have to
manually set them in the :class:`Cell` initialization procedure.
They are generated by the initialization function based on the attribute
:attr:`precision` which is a raw parameter to control the effective accuracy of
the calculation.  Nevertheless, we have to adjust these attributes in some
systems, especially when the diffused basis functions are employed.  For
example, in the following primitive cell of Diamond crystal, the default
:attr:`nimgs` (5,5,5) is not able to produce enough accuracy to guarantee
the periodicity.  It breaks the positive definition of the overlap matrix::

    import numpy
    from pyscf.pbc import gto
    cell = gto.M(atom = '''
    C 0.000000000000  0.000000000000  0.000000000000
    C 1.685068664391  1.685068664391  1.685068664391''',
    unit='B',
    basis = 'gth-dzvp',
    pseudo = 'gth-pade',
    h = '''
    0.000000000  3.370137329  3.370137329
    3.370137329  0.000000000  3.370137329
    3.370137329  3.370137329  0.000000000''',
    gs = [7,7,7])
    kpts = cell.make_kpts([2,2,2])
    sk = cell.pbc_intor('cint1e_ovlp_sph', kpts=kpts)
    print(cell.nimgs)
    print(numpy.linalg.eigh(s)[3][0])  # not positive-definite

    cell.nimgs = [6,6,6]
    sk = cell.pbc_intor('cint1e_ovlp_sph', kpts=kpts)
    print(numpy.linalg.eigh(s)[3][0])  # positive-definite

When you got Linear ``LinAlgError`` from ``scipy.linalg.eigh`` function with the
`not positive definite` error, it is very likely due to the truncation in the
real space lattice summation.  Increasing :attr:`nimgs` can solve this issue in
most scenario.

Besides the methods and parameters provided by :class:`Mole` class (see Chapter
:ref:`gto`), There are some parameters constantly used in the code to access the
information of the crystal.

kpts
  The scaled or absolute k-points (nkpts x 3 array). This variable is not held as an
  attribute in `Cell` object.  `Cell` object provides functions to generate the
  k-points and convert the k-points between the scaled (fractional) value and
  absolute value::

    # Generate k-points
    n_kpts_each_direction = [2,2,2]
    abs_kpts = cell.make_kpts(n_kpts_each_direction)

    # Convert k-points between two convention, the scaled and the absoulte values
    scaled_kpts = cell.get_scaled_kpts(abs_kpts)
    abs_kpts = cell.get_abs_kpts(scaled_kpts)

Gv
  The (N x 3) array of plane waves associated to :attr:`gs`.  :attr:`gs` defines
  the number of FFT grids in each direction.  :meth:`Cell.Gv` or :meth:`get_Gv`
  convert the FFT-mesh to the plane waves.  ``Gv`` are the the plane wave bases
  of 3D-FFT transformation.  Given ``gs = [nx,ny,nz]``, the number of vectors in
  ``Gv`` is ``(2*nx+1)*(2*ny+1)*(2*nz+1)``.

nimgs
  :attr:`nimgs` is the number of repeated images in each direction to mimic the
  periodicity.  It is mainly affected by the diffuse functions in the basis set.
  You may need increase the number of repeated images as shown by the above
  example to restore the periodicity.  The range of lattice summation is
  determined by this variable.  :class:`Cell` provides the function
  :func:`get_lattice_Ls` to convert the number of repeated images to the
  translation vectors of lattice summation.  This function is widely used in
  both the analytical and the numerical PBC integration.

vol
  :attr:`Cell.vol` gives the volume of the unit cell (in atomic unit).

energy_nuc
  Similar to the :func:`energy_nuc` provided by :class:`Mole` class, this
  function also return the energy associated to the nuclear repulsion.  The
  nuclear repulsion energy is computed with Ewald summation technique.  The
  background contribution is removed from the nuclear repulsion energy otherwise
  this term is divergent.

pbc_intor
  PBC analytic integral driver.  It allows user to compute the PBC integral
  array in bulk, for given integral descriptor ``intor`` (see also
  :meth:`Mole.intor` function :ref:`gto_moleintor`).  In the :class:`Cell` object,
  we didn't overload the :meth:`intor` method.  So one can access both the
  periodic integrals and free-boundary integrals within the :class:`Cell`
  object.  It allows you to input the cell object into the molecule program to
  run the free-boundary calculation (see :ref:`cell_to_mol`).

.. note::
  :meth:`pbc_intor` does not support Coulomb type integrals.  Calling pbc_intor
  with Coulomb type integral descriptor such as ``cint1e_nuc_sph`` leads to
  divergent integrals.  The Coulomb type PBC integrals should be evaluated with
  density fitting technique (see Chapter :ref:`pbc_df`).


Attributes and methods
----------------------

.. autoclass:: pyscf.pbc.gto.Cell
   :members:


.. _cell_to_mol:

Connection to :class:`Mole` class
---------------------------------
:class:`.Cell` class is compatible with the molecule
:class:`pyscf.gto.mole.Mole` class.  They shared most data structure and
methods.  It gives the freedom to mix the finite size calculation and the PBC
calculation.  If you feed the cell object to molecule module/functions, the
molecule program will not check whether the given :class:`Mole` object is the
true :class:`Mole` or not.  It simply treats the :class:`Cell` object as the
:class:`Mole` object and run the finite size calculations.  Because the same
module names were used in PBC program and molecule program, you should be
careful with the imported modules since no error message will be raised if you
by mistake input the :class:`Cell` object into the molecule program.

.. In a solid surface program, it allows you easily switching between the
.. periodicity and non-periodicity by calling different module with the same
.. ``Cell`` object.  However, for code readability, it is recommended to cast the
.. cell object into the regular molecule object using :meth:`Cell.to_mol`.

Although we reserve the flexibility to mix the :class:`Cell` and :class:`Mole`
objects in the same code, it should be noted that the serialization methods of
the two objects are not completely compatible.  When you dumps/loads the cell
object in the molecule program, informations of the :class:`Cell` object or the
faked :class:`Mole` object may be lost.


Serialization
-------------
:class:`Cell` class has two set of functions to serialize Cell object in
different formats.

* JSON format is the default serialization format used by :mod:`pyscf.lib.chkfile`
  module.  It can be serialized by :func:`Cell.dumps` function and deserialized
  by :func:`Cell.loads` function.

* In the old version, :func:`Mole.pack` and :func:`Mole.unpack` functions are
  used to convert the :class:`Mole` object to and from Python dict.  The Python
  dict is then serialized by pickle module.  This serialization method is not
  used anymore in the new PySCF code.  To keep the backward compatibility, the
  two methods are defined in :class:`Cell` class.


Basis set
=========
The pbc module supports all-electron calculation.  The all-electron basis sets
developed by quantum chemistry community can be directly used in the pbc
calculation.  The :class:`Cell` class supports to mix the QC all-electron basis
and PBC basis in the same calculation.

.. literalinclude:: ../../../examples/pbc/04-input_basis.py

.. note::

  The default PBC Coulomb type integrals are computed using FFT transformation.
  If the all-electron basis are used, you might need very high energy cutoff to
  converge the integrals.  It is recommended to use mixed density fitting
  technique (:ref:`pbc_df`) to handle the all-electron calculations.


.. _pseudo:

Pseudo potential
================
Quantum chemistry community developed a wide range of pseudo potentials (which
are called ECP, effective core potential) for heavy elements.  ECP works quite
successful in finite system.  It has high flexibility to choose different core
size and relevant basis sets to satisfy different requirements on accuracy,
efficiency in different simulation scenario.  Extending ECP to PBC code enriches
the pseudo potential database.  PySCF PBC program supports both the PBC
conventional pseudo potential and ECP and the mix of the two kinds of potentials
in the same calculation.

.. literalinclude:: ../../../examples/pbc/05-input_pp.py

