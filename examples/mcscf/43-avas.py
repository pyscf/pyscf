#!/usr/bin/env python
#
# Author: Elvira R. Sayfutyarova <elviras@princeton.edu>
#         Qiming Sun <osirpt.sun@gmail.com>
#

'''
Section IV.A of AVAS paper  arXiv:1701.07862 [physics.chem-ph]
'''

from functools import reduce
import numpy
from pyscf import gto
from pyscf import scf
from pyscf import mcscf
from pyscf import fci

#=============example: FERROCENE====================

mol = gto.Mole()
mol.atom = '''
Fe     0.000000    0.000000    0.000000 
C     -0.713500   -0.982049   -1.648000 
C      0.713500   -0.982049   -1.648000 
C      1.154467    0.375109   -1.648000 
C      0.000000    1.213879   -1.648000 
C     -1.154467    0.375109   -1.648000 
H     -1.347694   -1.854942   -1.638208 
H      1.347694   -1.854942   -1.638208 
H      2.180615    0.708525   -1.638208 
H      0.000000    2.292835   -1.638208 
H     -2.180615    0.708525   -1.638208 
C     -0.713500   -0.982049    1.648000 
C     -1.154467    0.375109    1.648000 
C     -0.000000    1.213879    1.648000 
C      1.154467    0.375109    1.648000 
C      0.713500   -0.982049    1.648000 
H     -1.347694   -1.854942    1.638208 
H     -2.180615    0.708525    1.638208 
H      0.000000    2.292835    1.638208 
H      2.180615    0.708525    1.638208 
H      1.347694   -1.854942    1.638208  
'''
mol.basis = 'cc-pvtz-dk'
mol.spin = 0
mol.build()

mf = scf.sfx2c1e(scf.ROHF(mol))
mf.kernel()

#
# The active space can be generated by pyscf.mcscf.avas.avas function
#
from pyscf.mcscf import avas
norb, ne_act, orbs = avas.avas(mf, ['Fe 3d', 'C 2pz'], canonicalize=False)

#
# The followings are the step-by-step solution to construct the active space
# based on the formulas provided by the paper.
#

#====================================================================
#  To choose AOs for a given atom and a given shell to project into
#====================================================================
def AOset(mol, AO_id, l, shell):
  AOs =[]
  m=-l
  for i in range (2*l+1):
    AOs.append(mol.search_ao_nr(AO_id,l,m,shell))
    m +=1
  return AOs
#====================================================================
#add the set to the active space
#====================================================================
def incl2AS(AS, add_set):
   for i in range(len(add_set)):
    AS.append(add_set[i])
   return AS
#====================================================================



mol2=mol.copy()
mol2.basis = 'MINAO'
mol2.build()

HF_MOcoeff =mf.mo_coeff
HF_occ = mf.mo_occ
N_total =len(mf.mo_energy)
print 'Total number of HF MOs  is equal to    ' ,N_total

N_occ=0
for i in range (N_total):
   if HF_occ[i] > 0:
     N_occ+=1

print 'Number of occupied HF MOs is equal to  ', N_occ

labels = mol.spheric_labels(0)
N_AO = len (labels)
labels = mol2.spheric_labels(0)
print 'Number of occupied AOs is equal to  ', N_AO
S_11=mol.intor_symmetric("cint1e_ovlp_sph")
S_22=mol2.intor_symmetric("cint1e_ovlp_sph")
S_21 = gto.intor_cross('cint1e_ovlp_sph', mol2, mol)
#====================================================================
#    CHOOSE AOs for Projector 
#====================================================================
AO =  AOset(mol2, 0, 2, 3) # choose 3d orbs for  Fe, atom with id0

for i in range (1,6):
 AO.append(mol2.search_ao_nr(i,1,1,2)) #add pz orbs of C from the 1st ring
for j in range (11,16):
 AO.append(mol2.search_ao_nr(j,1,1,2)) #add pz orbs of C from the 2nd ring

Np_AO=len(AO)

for i in range (Np_AO):
 idx= AO[i]
 print idx, '  ', labels[idx]

AO=numpy.sort(AO)

#=====================================================================
#           Building active space 
#=====================================================================
S_AO22= numpy.zeros ((Np_AO,Np_AO))
S_AO21= numpy.zeros ((Np_AO,N_AO))
for i in range (Np_AO):
 for j in range (Np_AO):
  ii=AO[i]
  jj=AO[j]
  S_AO22[i][j]=S_22[ii][jj]
 
for i in range (Np_AO):
 for j in range (N_AO):
  ii=AO[i]
  S_AO21[i][j]=S_21[ii][j]


S_AOi22=numpy.linalg.solve(S_AO22,S_AO21)
P_11=numpy.dot(S_AO21.T,S_AOi22)


MO_o= HF_MOcoeff[:, 0:N_occ]
MO_u= HF_MOcoeff[:, N_occ:N_total]
den_1=numpy.dot(MO_o,MO_o.T)

OccS   = reduce(numpy.dot,(MO_o.T,P_11,MO_o))
UnoccS = reduce(numpy.dot,(MO_u.T,P_11,MO_u))

e_values0,e_vectors0 = numpy.linalg.eigh(OccS)
e_valuesU,e_vectorsU = numpy.linalg.eigh(UnoccS)

print '================================================================'
print e_values0
print '================================================================'
print e_valuesU
print '================================================================'


NoAct=[]
NoCore=[]
NuAct=[]
NuVir=[]

for i in range (N_occ):
 if (e_values0[i]>0.1) :
   NoAct.append(i)
 else:
   NoCore.append(i)
print '    ACTIVE FROM OCCUPIED' , NoAct
print '    INACTIVE FROM OCCUPIED' , NoCore

for i in range (N_total-N_occ):
 if (e_valuesU[i]>0.1) :
   NuAct.append(i)
 else:
   NuVir.append(i)


print '    ACTIVE FROM UNOCCUPIED' , NuAct
print '    INACTIVE FROM UNOCCUPIED' , NuVir

occ2Core = e_vectors0[:,NoCore]
occ2Act  = e_vectors0[:,NoAct]
Unocc2Act= e_vectorsU[:,NuAct]
Unocc2Vir= e_vectorsU[:,NuVir]

occCore  = numpy.dot(MO_o,occ2Core)
occAct   = numpy.dot(MO_o,occ2Act)
UnoccAct = numpy.dot(MO_u,Unocc2Act)
UnoccVir = numpy.dot(MO_u,Unocc2Vir)
print ' dimensions of occCore ', occCore.shape[0], occCore.shape[1]
print ' dimensions of occAct ', occAct.shape[0], occAct.shape[1]
print ' dimensions of UnoccAct ', UnoccAct.shape[0], UnoccAct.shape[1]
print ' dimensions of UnoccVir ', UnoccVir.shape[0], UnoccVir.shape[1]

N_act_occ = len(NoAct)
N_act_vir = len(NuAct)

MO_o2=numpy.hstack((occCore,occAct))
den_2=numpy.dot(MO_o2,MO_o2.T)
denocc=numpy.dot(MO_o2.T,MO_o2)

Active=numpy.hstack((occAct,UnoccAct))
print ' dimensions of Active ',Active.shape[0], Active.shape[1]

AS=numpy.arange(N_occ-N_act_occ,N_occ+N_act_vir)
print AS

orbs = numpy.hstack((occCore,occAct,UnoccAct,UnoccVir))
print ' dimensions of coeff ',orbs.shape[0], orbs.shape[1]
s=mol.spin
nalpha=N_act_occ
nbeta=N_act_occ-s
ne_act=nalpha+nbeta
norb =len(AS)
print '# of alpha   ', nalpha
print '# of beta   ', nbeta

#==================================================================================
#             run CASSCF with this active space for 7 singlet and 6 triplet states
#==================================================================================


weights = numpy.ones(13)/13
solver1 = fci.addons.fix_spin(fci.direct_spin1.FCI(mol), ss=2)
solver1.spin = 2
solver1.nroots = 6
solver2 = fci.addons.fix_spin(fci.direct_spin1.FCI(mol), ss=0)
solver2.spin = 0
solver2.nroots = 7

mycas = mcscf.CASSCF(mf, norb, ne_act)
mycas.chkfile ='fecp2_3dpz.chk'
mcscf.state_average_mix_(mycas, [solver1, solver2], weights)
mycas.verbose = 6
mycas.kernel(orbs)


